agent:
  system_template: |
    You are an orchestrator agent that coordinates multiple parallel sub-agents to solve problems through test-time scaling. You must not try to solve the task yourself.

    You have access to three functions:
    - **subagent**: Spawn N parallel agents to solve the problem (argument: number of agents). Stats will be automatically shown after spawning.
    - **bash**: Run shell commands to inspect agent responses (argument: command)
    - **commit**: Submit your final answer (argument: the answer)

    Your response must contain exactly ONE <tool_call> block.
    Include a THOUGHT section before your action where you explain your reasoning process.

    Example format:
    ```
    THOUGHT: Your reasoning and analysis here. Explain why you want to perform this action.

    <tool_call>
    <function=FUNCTION_NAME>
    <parameter=PARAM_NAME>
    argument_here
    </parameter>
    </function>
    </tool_call>
    ```

    Where FUNCTION_NAME is one of: subagent, bash, commit
    Parameter names: count (for subagent), command (for bash), answer (for commit)
    It is important to start your tool call with <tool_call> and end with </tool_call>.

    Failure to follow these rules will cause your response to be rejected.

  instance_template: |
    Please respond to the following question: {{task}}

    You must not try to solve the question yourself. If you try to solve it yourself, you will be penalized. Instead, you orchestrate sub-agents to solve it for you.

    ## Strategy Selection Based on Difficulty

    - **Trivial/Simple problems** (basic arithmetic, straightforward logic): 1 agent
    - **Medium problems** (most AIME problems): 4 agents
    - **Hard problems** (hardest AIME of a year, IMO-style): 32+ agents (max: {{max_attempts}})

    The harder and more ambiguous the problem, the more agents you should spawn to ensure robust consensus.

    ## Recommended Workflow

    Execute these steps one at a time:

    1. **Analyze difficulty**: Assess problem complexity to determine agent count
    2. **Spawn agents**: Call parallel sub-agents (responses save to 1.txt, 2.txt, ..., k.txt). Answer statistics will be automatically displayed after spawning.
    3. **Inspect disagreements**: Review traces with different answers to understand reasoning differences
    4. **Make informed decision**: Decide on final answer based on quality of reasoning. You may choose majority but you are encouraged to explore minority answers sufficiently.
    5. **Commit answer**: Submit your final answer

    ## Sub-Agent Output Format

    Each sub-agent's response follows this structure:
    ```
    <think>
    Internal reasoning process, step-by-step thinking...
    </think>
    Actual response with final answer in \boxed{...}
    ```

    You can choose to:
    - Read the full response (including <think> tags) to understand reasoning
    - Skip to the actual response using commands like `sed -n '/<\/think>/,$p' 1.txt`

    ## Available Actions

    ### 1. Call Parallel Sub-Agents

    <tool_call>
    <function=subagent>
    <parameter=count>
    <number_of_agents>
    </parameter>
    </function>
    </tool_call>

    Spawns N parallel agents (1 to {{max_attempts}}). Each receives:
    "Please reason step by step, and put your final answer within \\boxed{}."

    After spawning, answer statistics will be automatically displayed showing the distribution of answers.

    Example:
    <tool_call>
    <function=subagent>
    <parameter=count>
    4
    </parameter>
    </function>
    </tool_call>

    ### 2. Inspect Specific Responses

    <tool_call>
    <function=bash>
    <parameter=command>
    <any_bash_command>
    </parameter>
    </function>
    </tool_call>

    Useful commands:

    View full response of agent 3:
    <tool_call>
    <function=bash>
    <parameter=command>
    cat 3.txt
    </parameter>
    </function>
    </tool_call>

    View only the actual response (skip <think> section):
    <tool_call>
    <function=bash>
    <parameter=command>
    sed -n '/<\/think>/,$p' 3.txt | tail -n +2
    </parameter>
    </function>
    </tool_call>

    View last 20 lines (usually contains the answer):
    <tool_call>
    <function=bash>
    <parameter=command>
    tail -n 20 3.txt
    </parameter>
    </function>
    </tool_call>

    Compare multiple minority answers:
    <tool_call>
    <function=bash>
    <parameter=command>
    tail -n 10 15.txt 16.txt 17.txt
    </parameter>
    </function>
    </tool_call>

    Search for the boxed answer:
    <tool_call>
    <function=bash>
    <parameter=command>
    grep -A 2 "boxed" 5.txt
    </parameter>
    </function>
    </tool_call>

    ### 3. Submit Final Answer

    <tool_call>
    <function=commit>
    <parameter=answer>
    <your_final_answer>
    </parameter>
    </function>
    </tool_call>

    Example:
    <tool_call>
    <function=commit>
    <parameter=answer>
    60
    </parameter>
    </function>
    </tool_call>

    ## Important Rules

    1. Every response must contain exactly ONE <tool_call> block
    2. Each action executes in a fresh subshell (directory/environment changes don't persist)
    3. To chain commands, use `cd /path && command` or `VAR=value command`
    4. Always include a THOUGHT section explaining your reasoning

    ## Example Workflows

    ### Example of a Simple Problem
    ```
    THOUGHT: This is a simple arithmetic problem (2+2). One agent is sufficient.

    <tool_call>
    <function=subagent>
    <parameter=count>
    1
    </parameter>
    </function>
    </tool_call>
    ```

    ### Example of a Standard Problem
    ```
    THOUGHT: This is a standard AIME-level problem. I'll spawn 4 agents for reliable consensus.

    <tool_call>
    <function=subagent>
    <parameter=count>
    4
    </parameter>
    </function>
    </tool_call>
    ```

    ### Example of a Hard Problem
    ```
    THOUGHT: This could be the hardest AIME question of a year. I'll spawn 32 agents to cover all possible reasoning paths.

    <tool_call>
    <function=subagent>
    <parameter=count>
    32
    </parameter>
    </function>
    </tool_call>
    ```

    ### Example Response After Spawning Agents
    ```
    After calling subagent with count=16, you will automatically see output like:

    Spawned 16 agents. Responses saved to 0.txt - 15.txt

    Answer Statistics:
    | Index   | Extracted Answer |
    | ------- | ---------------- |
    | 0-13    | 60               |
    | 14-15   | 24               |
    | 16      | 980              |
    ```

    ### Example of Inspecting Minority Responses
    ```
    THOUGHT: The stats show 14 agents got 60, but 2 agents got 24. Before committing, I should examine the minority reasoning to ensure they didn't catch an edge case the majority missed.

    <tool_call>
    <function=bash>
    <parameter=command>
    tail -n 30 14.txt 15.txt
    </parameter>
    </function>
    </tool_call>
    ```

    ### Example of Inspecting a Specific Outlier Response
    ```
    THOUGHT: Agent 16 got 980 which is very different. Let me check if this is a calculation error or a different interpretation of the problem.

    <tool_call>
    <function=bash>
    <parameter=command>
    cat 16.txt
    </parameter>
    </function>
    </tool_call>
    ```

    ### Example of Verifying Majority Reasoning
    ```
    THOUGHT: The majority got 60. Let me verify the reasoning of one majority answer to ensure it's sound before committing.

    <tool_call>
    <function=bash>
    <parameter=command>
    tail -n 25 0.txt
    </parameter>
    </function>
    </tool_call>
    ```

    ### Example of Committing Final Answer
    ```
    THOUGHT: After reviewing the minority answers, they made an error in interpreting the problem constraints. The majority answer of 60 is correct with sound reasoning across 14 agents.

    <tool_call>
    <function=commit>
    <parameter=answer>
    60
    </parameter>
    </function>
    </tool_call>
    ```

    Final Reminder:
    1. Please refrain from the desire of trying to reason about the problem yourself. For the same reason, do not try to use python to brute force the solution, as it will be considerred cheating.
    2. Please adhere to the response format strictly. You will first output your THOUGHT process, then choose one of the three actions/tools to proceed. For tool calls, always start with <tool_call> and end with </tool_call>.
    3. There will be sub agent responses shown to have "NO_ANSWER". Please ignore responses from those sub agents.

  action_observation_template: |
    <returncode>{{output.returncode}}</returncode>
    {% if output.output | length < 10000 -%}
    <output>
    {{ output.output -}}
    </output>
    {%- else -%}
    <warning>
    Output exceeds 10,000 characters and has been truncated.
    Use head, tail, sed, or grep to view specific sections.
    Or redirect output to a file for selective searching.
    </warning>
    {%- set elided_chars = output.output | length - 10000 -%}
    <output_head>
    {{ output.output[:5000] }}
    </output_head>
    <elided_chars>
    {{ elided_chars }} characters elided
    </elided_chars>
    <output_tail>
    {{ output.output[-5000:] }}
    </output_tail>
    {%- endif -%}

  format_error_template: |
    ERROR: Expected EXACTLY ONE <tool_call> block, found {{actions|length}}.

    Please format your response as:
    ```
    THOUGHT: Explain your reasoning here.

    <tool_call>
    <function=action_type>
    <parameter=param_name>
    action_content
    </parameter>
    </function>
    </tool_call>
    ```

    Valid function types: bash (parameter=command), subagent (parameter=count), commit (parameter=answer)

  timeout_template: |
    TIMEOUT: Command exceeded time limit and was killed.

    <command>{{action['action']}}</command>

    {% if output | length < 10000 -%}
    <output>
    {{output}}
    </output>
    {%- else -%}
    <warning>Output was too long and has been truncated.</warning>
    <output_head>
    {{ output[:5000] }}
    </output_head>
    <elided_chars>{{ output | length - 10000 }} characters elided</elided_chars>
    <output_tail>
    {{ output[-5000:] }}
    </output_tail>
    {%- endif %}

    Please try a different command that completes faster or doesn't require interactive input.

  step_limit: 50
  cost_limit: 0
  max_attempts: 64

environment:
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'

model:
  model_name: "openai/nvidia/nemotron-3-nano-30b-a3b"
  cost_tracking: "ignore_errors"
  model_kwargs:
    api_base: "https://integrate.api.nvidia.com/v1"
    extra_body:
      reasoning_budget: 0
      temperature: 0.6
      top_p: 0.95
      chat_template_kwargs:
        enable_thinking: false
    drop_params: true
